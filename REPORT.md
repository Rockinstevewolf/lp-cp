# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Баранников Степан Алексеевич

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |     21.12.19         |          3     |
| Левинская М.А.|              |               |

> *Задание 5 не выполнено. Собеседование по коду не слишком успешно, часть кода заимствована без глубокого понимания работы*

## Введение

 1. С помощью сервиса MyHeritage.com создано родословное дерево, после чего экспортировано на компьютер в виде текстового файла с расширением `".ged"`.
 2. Далее, ознакомившись с видом данных, которые хранятся в файле `heritage.ged`, данное родословное дерево было сконвертировано на набор утверждений языка Prolog.
 3.

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: `parent(родитель, ребенок)`, `sex(человек, m/f)`
 3. Реализовать предикат проверки/поиска `3. Золовка`
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Дерево было получено с помощью сервиса `MyHeritage.com`. Оно хранится в файле `"heritage.ged"`. В данном дереве `39` персон: `22` мужчин и `17` женщин.
Максимальное уровень поколения - `4`.

## Конвертация родословного дерева

Для решения данной задачи я использовал язык `С++` поскольку он имеет обширный инструментарий и пока что является моим основным языком программирования. Принцип действия программы основан на одноразовом прохождении по файлу `heritage.ged`, получая строки с помощью функции `getline(file,line)`, где `line` имеет формат `string`, и по ключевым знакам в строках с помощью условных операций я выделял для себя нужные данные с помощью  `line.subline()` и сохранял их в массив, созданный с помощью метода `vector`. Таким образом, был создан массив семей, каждый из членов которых содержит в себе поля: ИМЯ и ПОЛ. Сравнение данных и сохранение их в нужном формате происходят одновременно с получением данных из файла, хотя это также можно делать и после прохождения по файлу.

Итоговый файл `list.pl`:
```Prolog
parent('Алексей Владимирович Баранников','Степан Алексеевич Баранников').
parent('Алексей Владимирович Баранников','Василиса Алексеевна Баранникова').
parent('Варвара Юрьевна Максимова','Степан Алексеевич Баранников').
parent('Варвара Юрьевна Максимова','Василиса Алексеевна Баранникова').
parent('Владимир Адольфович Баранников','Алексей Владимирович Баранников').
parent('Владимир Адольфович Баранников','Андрей Владимирович Баранников').
parent('Ирина Владимировна Баврина','Алексей Владимирович Баранников').
parent('Ирина Владимировна Баврина','Андрей Владимирович Баранников').
parent('Андрей Владимирович Баранников','Макар Андреевич Баранников').
parent('Ольга Ельцина','Макар Андреевич Баранников').
parent('Юрий Сергеевич Максимов','Варвара Юрьевна Максимова').
parent('Любовь Аркадьевна Крылова','Варвара Юрьевна Максимова').
parent('Аркадий Александрович Крылов','Любовь Аркадьевна Крылова').
parent('Татьяна Ивановна Пушкина','Любовь Аркадьевна Крылова').
parent('Адольф Венедиктович Шнейдер','Александр Адольфович Баранников').
parent('Адольф Венедиктович Шнейдер','Владимир Адольфович Баранников').
parent('Агния Александровна Баранникова','Александр Адольфович Баранников').
parent('Агния Александровна Баранникова','Владимир Адольфович Баранников').
parent('Владимир Алексеевич Баврин','Елена Владимировна Баврина').
parent('Владимир Алексеевич Баврин','Ирина Владимировна Баврина').
parent('Лидия Федоровна Скотникова','Елена Владимировна Баврина').
parent('Лидия Федоровна Скотникова','Ирина Владимировна Баврина').
parent('Михаил Матвиец','Надежда Михайловна Матвиец').
parent('Татьяна Ивановна Пушкина','Надежда Михайловна Матвиец').
parent('Сергей Васильевич Максимов','Юрий Сергеевич Максимов').
parent('Сергей Васильевич Максимов','Валерий Сергеевич Максимов').
parent('Сергей Васильевич Максимов','Лидия Максимова').
parent('Варвара Петровна Петрова','Юрий Сергеевич Максимов').
parent('Варвара Петровна Петрова','Валерий Сергеевич Максимов').
parent('Варвара Петровна Петрова','Лидия Максимова').
parent('Надежда Михайловна Матвиец','Михаил Пославский').
parent('Владимир Иванович Власов','Иван Владимирович Власов').
parent('Владимир Иванович Власов','Мария Владимировна Власова').
parent('Елена Владимировна Баврина','Иван Владимирович Власов').
parent('Елена Владимировна Баврина','Мария Владимировна Власова').
parent('Александр Адольфович Баранников','Евгений Александрович Баранников').
parent('Александр Адольфович Баранников','Елена Александровна Баранникова').
parent('Маргарита ','Евгений Александрович Баранников').
parent('Маргарита ','Елена Александровна Баранникова').
parent('Иван Владимирович Власов','Александра Ивановна Власова').
parent('Татьяна ','Александра Ивановна Власова').
parent('Евгений Ломакин','Роман Евгеньевич Ломакин').
parent('Евгений Ломакин','Максим Евгеньевич Власов').
parent('Мария Владимировна Власова','Роман Евгеньевич Ломакин').
parent('Мария Владимировна Власова','Максим Евгеньевич Власов').
parent('Unknown','Никита ').
parent('Елена Александровна Баранникова','Никита ').
sex('Степан Алексеевич Баранников','m').
sex('Василиса Алексеевна Баранникова','f').
sex('Алексей Владимирович Баранников','m').
sex('Варвара Юрьевна Максимова','f').
sex('Андрей Владимирович Баранников','m').
sex('Владимир Адольфович Баранников','m').
sex('Ирина Владимировна Баврина','f').
sex('Ольга Ельцина','f').
sex('Юрий Сергеевич Максимов','m').
sex('Любовь Аркадьевна Крылова','f').
sex('Аркадий Александрович Крылов','m').
sex('Татьяна Ивановна Пушкина','f').
sex('Адольф Венедиктович Шнейдер','m').
sex('Агния Александровна Баранникова','f').
sex('Владимир Алексеевич Баврин','m').
sex('Лидия Федоровна Скотникова','f').
sex('Макар Андреевич Баранников','m').
sex('Александр Адольфович Баранников','m').
sex('Надежда Михайловна Матвиец','f').
sex('Сергей Васильевич Максимов','m').
sex('Варвара Петровна Петрова','f').
sex('Валерий Сергеевич Максимов','m').
sex('Лидия Максимова','f').
sex('Михаил Матвиец','m').
sex('Михаил Пославский','m').
sex('Елена Владимировна Баврина','f').
sex('Иван Владимирович Власов','m').
sex('Владимир Иванович Власов','m').
sex('Мария Владимировна Власова','f').
sex('Маргарита ','f').
sex('Евгений Александрович Баранников','m').
sex('Елена Александровна Баранникова','f').
sex('Александра Ивановна Власова','f').
sex('Татьяна ','f').
sex('Максим Евгеньевич Власов','m').
sex('Евгений Ломакин','m').
sex('Роман Евгеньевич Ломакин','m').
sex('Никита ','m').
sex('Unknown','m').

```

## Предикат поиска родственника

Предикат `find_zolovka/1` возвращает в список девушек:
```Prolog
:- ['list.pl'].

%%%%%%%%%%%%%% Поиск золовки, возвращает список девушек, подходящих устловию
find_zolovka(Ans_bag):-
	findall(D, (parent(A,X), sex(A,f), parent(B,X), sex(B,m), parent(Y,B), parent(Y,D), sex(D,f)), Ans),
	list_to_set(Ans, Ans_bag).

%%%%%%%%%%%%%% Поиск возможных решений задачи, просмотреть все можно нажатием на пробел во время исполнения
find_some_zolovka(D):-
	parent(A,X), sex(A,f),
	parent(B,X), sex(B,m),
	parent(Y,B),
	parent(Y,D), sex(D,f).

```
Предикат `find_zolovka` находит и печатает список в особом виде:
```Prolog
%%%%%%%%%%%%%% То же самое, просто интересный метод хранения и выведения данных. Так сказать, эксперимент с findall'ом...
write_bag([]).
write_bag([H|T]):-
	H=[[A, A1], [B, B1], [C, C1]],
	write(A), write(A1), write('	->	'), write(B), write(B1), write(' ; '), write(C), write(C1), nl,
	write_bag(T).

find_zolovka_fun:-
	findall([['(ЗОЛОВКА) ', D], ['(МУЖ) ', B], ['(ЖЕНА) ', A]], (parent(A,X), sex(A,f), parent(B,X), sex(B,m), parent(Y,B), parent(Y,D), sex(D,f)), Ans),
	list_to_set(Ans, Ans_bag), write_bag(Ans_bag).

```
Вызов предиката:
```Prolog
?- find_zolovka(X).
X = ['Лидия Максимова', 'Мария Владимировна Власова'].


%Вывод повторный, поскольку используется предикат parent/2 по общему родителю, где может выводиться человек как по отцу, так и по матери 
?- find_some_zolovka(Ans).
Ans = 'Лидия Максимова' ;
Ans = 'Лидия Максимова' ;
Ans = 'Мария Владимировна Власова' ;
Ans = 'Мария Владимировна Власова' ;
false.

?- find_zolovka_fun.
(ЗОЛОВКА) Лидия Максимова       ->      (МУЖ) Юрий Сергеевич Максимов ; (ЖЕНА) Любовь Аркадьевна Крылова
(ЗОЛОВКА) Мария Владимировна Власова    ->      (МУЖ) Иван Владимирович Власов ; (ЖЕНА) Татьяна
true.
```

## Определение степени родства

Для нахождения степени родства мне потребовалось использовать знания, накопленные в процессе выполнения 3 лабораторной работы на поиск в пространстве состояний. Для поиска пути я использовал поиск в ширину 'search_bdth/3'. И, соответственно, сначала определил предикат `move/2`, оперирующий предикатами `link/3`:

```Prolog
link(husband, Husband, Wife):-
	parent(Husband,X),
	parent(Wife,X),
	sex(Husband,m), sex(Wife,f).

link(wife, Wife, Husband):-
	parent(Husband,X),
	parent(Wife,X),
	sex(Husband,m), sex(Wife,f).

link(brother, Brother, Y):-
	parent(X,Brother),
	parent(X,Y),
	sex(Brother,m).

link(sister, Sister, Y):-
	parent(X,Sister),
	parent(X,Y),
	sex(Sister,f).

link(father, Father, Child):-
	parent(Father,Child),
	sex(Father,m).

link(mother, Mother, Child):-
	parent(Mother,Child),
	sex(Mother,f).

link(parent, Parent, Child):-
    parent(Parent,Child).

link(son, Child, Parent):-
    parent(Parent,Child),
    sex(Child,m).

link(daughter, Child, Parent):-
	parent(Parent,Child),
	sex(Child,f).

link(child, Child, Parent):-
    parent(Parent,Child).

move(X,Y):- link(_,X,Y).
```

Далее, сам поиск в ширину `search_bdth/3`:

```Prolog
prolong([X | T], [Y, X | T]):-
    move(X, Y),
    not(member(Y, [X | T])).

% В случае если X находится в начале очереди, получает состояние, где содержится X
bdth([[X | T] | _], X, [X | T]).
%Ищет все пути из текущего состояния и производит слияние этих путей с текущей очередью, после чего продолжает с новым состоянием в очереди
bdth([P | Q], B, R):-
    findall(X, prolong(P, X), L),
    append(Q, L, QL),
    bdth(QL, B, R), !.
% Перенаправляющее состояние, которое происходит, если не достигается конечное состояние B, то есть отправляет в хвост списка (очередь)
bdth([_ | Q], B, R):- bdth(Q, B, R).

search_bdth(X , Y, P):-
    bdth([[X]], Y, L),
    reverse(L, P).
```

И, наконец, предикаты, обрабатывающие ответы `relative_names/3`, `relative_types/3`, использующий `transform/2` для получения другого вида записи данных, и общий предикат `relative/3`:

```Prolog
% Получение списка имен между двумя родственниками
relative_names(X, Y, Ans):-
    search_bdth(X, Y, Ans).

% Конвертация списка имен в список типов родства между двумя соседними родственниками
transform([_], []):- !. 
transform([A,B|T], Ans):-
    link(Rel, A, B),
    Ans = [Rel|Buf],
    transform([B|T], Buf), !.

relative_types(X, Y, Ans):-
    search_bdth(X, Y, Ans1),
    transform(Ans1, Ans).

relative(X, Y):-
	relative_names(X, Y, B),
	transform(B, A),
	write(A), nl, write(B).
```

## Естественно-языковый интерфейс

Отсутствует, однако есть очень много идей, как можно это все реализовать.
Прошу прощения, что не постарался сделать данное задание.

## Выводы

Очень достойная Курсовая работа, коих на самом деле, в нашей учебе бывает мало. Но сейчас не об этом. Данная лабораторная работа позволяет применить все знания, полученные в ходе выполнения Лабораторных работ в течение семестра (в моем случае - в конце семестра). Все задачи не сильно нагружены сложностью, что очень хорошо, поскольку их `4-5` в количестве, в то время как вдобавок еще нужно написать очень-таки содержательный реферат. В ходе написания Курсовой работы я получил немало позитивных ощущений и проработал ранее накопленные знания, за что я очень благодарен.
