# Реферат
## по курсу "Логическое программирование"

### студент: Баранников С.А.

## ТЕМА: Логические языки как первые языки для обучения программированию

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

В наше время трудно представить нашу жизнь без электронных устройств, в особенности без такого высоко-технологического оборудования, как Персональный компьютер. Но зачем же он нужен, что он может делать и как он это делает?

Для начала, физически, ПК - это комплекс электронных и программных составляющих, где на уровне электроники происходит перекачка энергий из одних состояний в другие, то есть изменение машинной информации, а на уровне программ - обработка этой же самой информации и ее переработка на язык человека. Так вот поговорим как раз о программном уровне работы с компьютером.

Первые языки программирования были ну уж очень примитивными и трудоемкими для того, чтобы программист мог осуществлять работу с машиной, посредством написания различного типа программ. Поэтому, чтобы облегчить работу с ЭВМ и избавить специалистов от самостоятельного манипулирования числовыми кодами машинных команд и распределения памяти компьютера под команды, программы и данные, были созданы языки программирования типа `Ассемблер`. Теперь, у переменных величин появились символические имена, а числовые коды получили вполне понятные обобщенные обозначения. То есть, компьютер стал ближе к человеку, благодаря повышению уровня работы с ним, посредством создания нового обобщенного языка. То есть люди научились переводить машинный язык электроники на язык человека.

Но что все-таки означает "повышение уровня взаимодействия человека с компьютером"? Получается ли, что люди достигли достаточного уровня легкости в понимании компьютера человеком? Если мы говорим об 'Ассемблере', то все еще нет. Определим для начала, что `Ассемблер` - язык строго "низкоуровневый", ниже него только сама машина. Тогда, получается, что можно попробовать подняться выше и, в каком-то смысле, стать ближе к "машинной расе"? Конечно же, можно. Ведь языки программирования - это как раз то, что человек развивает и по сей день, и их на данный момент уже настолько много, что даже подключив пальцы ног, вы не получите верного их количества. Далее, можно сказать, начали появляться различные "высокоуровневые" языки.

Так вот далее появился такой язык, как `Фортран` (`Formula Translation`), для работы с математическими данными, а также для решения математических или же использующих математический аппарат для своих целей задач. Так, сказать, появилась новая ступень в развитии языков.

Но нельзя же останавливаться только на математике. Ведь есть множество других сфер деятельности, которым требуются инструменты для работы с требуемыми данными. Оно и верно, поскольку когда нет предела, то остановиться просто невозможно. Таким образом, появились языки: `Кобол` (для экономики), `Снобол` и `Лисп` (для работы с алгоритмами, последний из которых широко полезен в исследованиях в сфере ИИ). Далее, появились всем известные `Паскаль` и `Бейсик`, которые в разы повысили уровень взаимодействия человека с машиной.

И, наконец-таки, на сцене появляется язык `Си`, который становится одним из самых универсальных языков программирования, поскольку в нем реализованы возможности как для высокоуровневого использования, так и для непосредственного обращения к машине и для самостоятельного распределения программистом памяти компьютера. Язык `Си` позволяет нам разрабатывать как операционные системы, так и базы данных и программы, требующиеся различным иным прикладным сторонам технической среды человека. То есть он вмещает в себя как и низкоуровневую, так и высокоуровневую методы работы с машиной. Помимо этого, язык этот очень эффективный и мощный, вследствие чего его можно сравнить по скорости даже с `Ассемблером`.

Вообще, есть много вариантов распределения языков по группам, помимо их уровня. Например язык `Си` является "функциональным" языком программирования, особенностью которого является возможность "рекурсии", то есть вызов той же функции внутри себя самой. Также определим и "логические" языки. Если рассматривать только логическую составляющую, например языка `Пролог`, о котором повествуется далее, то в логическом программировании не нужно описывать никаких действий, а требуется всего лишь задать соотношения между данными, после чего появляется возможность делать запросы по данным. Далее машиной перебираются ранее заданные данные и программа может выдать одно из двух состояний работы: `true` или `false`, то есть правда и неправда.

И, наконец, поговорим в целом о языке `Пролог`. Язык `Пролог` классифицируется как и функциональный, так и логический язык программирования. Он крайне полезен для решения задач анализа и понимания естественных языков, на основе `языка формальной логики и автоматического доказательства теорем`. А что такое этот язык "формальной логики"? Это говорит нам о том, что в данном языке происходит сильное погружение в метасимволику, которая позволяет нам "неявно" определить множество "явных" вещей, которые программа сама отлично распознает за нас, и, вследствие правильно заданных формулировок, даже решит наши задачи. Тут можно решать и логические загадки, и обрабатывать данные, можно создавать интерфейсы, использующие запросную символику. В общем, спектр языка достаточно велик, что дает относительно легкий порог вхождения, как мне кажется, допустим, именно для программиста, который уже изучал такой языки как `Си`. Ведь `Си` - это как раз такой же "функциональный" язык, который умеет работать с рекурсией, а при добавлении "логической" составляющей языка `Пролог` программисту легче внедриться в него, поскольку ему требуется всего лишь добавить к функциональным знаниям логические.

Но что же получается? Является ли `Пролог` таким же функциональным языком, как `Си`? Я бы сказал, что да. Единственное отличие в том, что в `Си` больше возможностей в работе с рекурсией: можно довольно-таки просто использовать итерраторы, можно глобально объявлять переменные, можно сделать рекурсию параллельной и многое, в то время как в `Пролог` рекурсия не имеет такой большой силы для функционального программирования. Однако, основная цель языка `Пролог` - логическая, что говорит нам как раз о том, что данный язык довольно-таки направлен в иную сторону и имеет свой не менее обширный спектр возможностей, по сравнению с другими языками программирования. И, как раз, рекурсия в `Пролог` требует продуманной логики в терминировании рекурсии, в то время как на `Си` не составит особого труда обозначить терминирующие состояния. Конечно же, может быть, это все очень субъективно, но все-таки приведу пару примеров своего мнения, то есть попробуем сравнить языки:

- Факториал на `Си`
```C
int Fact(int N) {
	int Answer;
	if(N == 1) {
		return(1);
	}
	else {
		Answer = Fact(N-1)*N;
		return(Answer);
	}
}

```
Здесь обязательно происходит явное определение величин, по которым определяется конец рекурсии (если n сравним с 1) и возвращение обратно и выглядит это все интуитивно понятно, поскольку при написании программы используется довольно-таки много конкретики.

- Факториал на `Пролог`
```Prolog
fact(N, F):-
	f(N, F, 1, 1).

f(N, F, N, F):- !.

f(N, F, N1, F1):-
	N11 is N1 + 1,
	F11 is F1 * N11,
	f(N, F, N11, F11).

```
В данной, же, ситуации все происходит немного по-другому: `Пролог` оперирует набором утверждений, состояний. Сверху вниз проверяются все утверждения на истинность, то есть важно определить правильный порядок всех предикатов.

Так вот в случае вызова `f(N, F, 1, 1)` мы начинаем с числа 1 и двигаемся вверх c помощью `f(N, F, N1, F1)`, в котором мы производим все арифметические действия, пока не встретим N, что описано предикатом `f(N, F, N, F)`.

Конечно, же возможно и это может оказаться интуитивно понятной логикой действий, однако тут важно понимать, что пролог работает методом поиска условий в пространстве состояний и их все нужно постараться продумать, в то время как такую функцию на языке `Си` можно легко и доступно объяснить даже ребенку, как минимум потому что в `Си` нет такой мета-абстракции, как в `Пролог`.

Попробую опровергнуть свое мнение, переписав коды с разных языков в виде псевдо-кодов:

- псевдо-код `Си` (Скобки {} обозначают начало и конец, а "целое_число" обозначает тип переменной)
```
целое_число Факториал_от(целое_число N){
	целое_число Ответ;
	если(N сравнимо_с 1) { то
		вернуть(1);
	}
	иначе {
		Ответ = Факториал_от(N-1) * N;
		вернуть(Ответ);
	}
}
```

- псевдо-код `Prolog` (Помимо самого кода требуется еще сообщить, что Пролог проверяет на истинность утверждения факт сверху вниз)
```
факториал_от(Число, Факт):-
	факт(Число, Факт, 1, 1).

факт(Число, Факт, Число, Факт):- Обратно_не_возвращаемся.

факт(Число, Факт, Число_1, Факт_1):-
	Число_11 есть Число_1 + 1,
	Факт_11 есть Факт_1 * Число_11,
	факт(Число, Факт, Число_11, Факт_11).
```

Итак, как по мне, псевдо-код `Си` выглядит все еще гораздо более читаемым для объяснения новичкам, пусть даже такой сложной задачи с рекурсией, нежели чем псевдо-код `Пролог`.

Но ведь я же рассмотрел лишь функциональную сторону языков, в то время как `Пролог` содержит в себе еще и логическую. Разве я прав?

И правда, однако, мы выяснили, что же может являться проблемой для совсем начинающего программиста в `Пролог`. Теперь же можно обратить внимание на то, что в `Си` нет такой же превосходной логики, как в пролог, например:

```Prolog
type(max, human).
type(kesha, parrot).
type(sasha, mouse).

ask(Name,Type):- 
	type(Name,Type).
```

Реализация:
```Prolog
?- ask(X,Y).
X = max,
Y = human ;
X = kesha,
Y = parrot ;
X = sasha,
Y = mouse.

?- type(X,Y).
X = max,
Y = human ;
X = kesha,
Y = parrot ;
X = sasha,
Y = mouse.

?- ask(X,human).
X = max.

?- ask(sasha,Y).
Y = mouse.

```

Подобные вещи, в принципе можно сделать и на `Си`, но это не будет так же просто, как я это сделал на `Пролог`. А если честно, то очень-очень будет сложно этого добиться.

Тогда, получается, что ответ на тему `Логические языки как первые языки для обучения программированию` будет крайне неоднозначен. То есть если вы хотите немного заняться логическими задачами, то можно попробовать и `Пролог` вначале своего пути программиста, но все же, не зная функциональной составляющей программирования, может быть очень тяжко работать на `Пролог`, изучая при этом такие сложные задачи, как, например, на поиск пути из одного состояния в другое.

